- [Генерация RSA ключей](#генерация-rsa-ключей)
- [Шифрование (для отправки)](#шифрование-для-отправки)
- [Пример шифрования](#пример-шифрования)
- [Дешифрование (для получения)](#дешифрование-для-получения)
- [Пример дешифрования](#пример-дешифрования)

<a id="генерация-rsa-ключей"></a>

## Генерация RSA ключей

```python
from Crypto.PublicKey import RSA

key = RSA.generate(1024)

private_key_pem = key.export_key()
public_key_pem = key.publickey().export_key()
```

<a id="шифрование-для-отправки"></a>

## Шифрование (для отправки)

- Получить текущую метку времени `timestamp`
- Объединить `timestamp` и `тело запроса` в строку `content`
  - Если используется метод HTTP `POST`, тело запроса представляет собой текст в формате JSON.
  - Если используется метод HTTP `GET`, тело запроса представляет собой неэкранированную строку запроса.
    - `name=foo&age=18` - допустимое значение.
    - `name%3dfoo%26age%3d18` - недопустимое значение.
- Подписать `content` с помощью SHA256 и PKCS1V15, 1024-битный RSA
- Закодировать подписанные байты в Base64.

<a id="пример-шифрования"></a>

## Пример шифрования

```python
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Signature import pkcs1_15
import base64

timestamp = str(int(time.time()))

body = {"tradeNo": "12345", "status": "processing"}
request_body = json.dumps(body, separators=(',', ':'))

content = f"{timestamp}{request_body}"

private_key = <"RSA_privat_key">

private_key = RSA.import_key(private_key)
data_hash = SHA256.new(content.encode('utf-8'))
signature_bytes = pkcs1_15.new(private_key).sign(data_hash)
signature = base64.b64encode(signature_bytes).decode('utf-8')

headers = {
    'Content-Type': 'application/json',
    'timestamp': timestamp,
    'signature': signature
    'publicKey': ваш_публичный_ключ_base64
}
```

<a id="дешифрование-для-получения"></a>

## Дешифрование (для получения)

- Получить текущую метку времени `timestamp` и `signature` из заголовка запроса
- Получить `тело ответа`
  - Если используется метод HTTP `POST`, тело запроса представляет собой текст в формате JSON.
  - Если используется метод HTTP `GET`, тело запроса представляет собой неэкранированную строку запроса.
- Объединить `timestamp` и `тело ответа` в строку `content`
- Раскодировать полученную `signature` из Base64
- Хэшировать содержимое строки с помощью SHA256 и проверьте `signature`, используя PKCS1V15, 1024-битный RSA.

<a id="пример-дешифрования"></a>

## Пример Дешифрования

```python
from flask import Flask, request
import json
import base64
from Crypto.PublicKey import RSA
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

app = Flask(__name__)

BYBIT_PUBLIC_KEY = "<RSA_public_key от биржи bybit>"

@app.route('/webhook', methods=['POST'])
def handle_webhook():
    timestamp = request.headers.get('timestamp')
    signature = request.headers.get('signature')
    
    body = request.get_data(as_text=True)
    
    if verify_signature(timestamp, signature, body):
        data = json.loads(body)
        print(data)
        return "OK", 200
    else:
        return "Invalid signature", 401

def verify_signature(timestamp, signature_b64, body):
    try:
        content = f"{timestamp}{body}"
        signature = base64.b64decode(signature_b64)
        content_hash = SHA256.new(content.encode('utf-8'))
        pkcs1_15.new(BYBIT_PUBLIC_KEY).verify(content_hash, signature)
        return True
    except:
        return False

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, ssl_context='adhoc')
```
